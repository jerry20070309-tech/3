<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>TRIDENT V46 PRO</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
body{background:#050505;color:#d4d4d8;font-family:monospace}
.bar{height:18px;border-radius:4px;transition:0.3s}
</style>
</head>
<body class="p-6">

<h1 class="text-2xl font-bold mb-4">TRIDENT V46 PRO</h1>
<button onclick="ignite()" class="bg-green-600 px-4 py-2 rounded text-white font-bold mb-4">
啟動掃描
</button>

<!-- 進度條 -->
<div class="mb-6">
<div class="flex justify-between text-xs mb-1">
<span>策略重算倒數</span>
<span id="countdown">等待資料</span>
</div>
<div class="w-full bg-zinc-800 h-2 rounded overflow-hidden">
<div id="progressBar" class="bg-emerald-500 h-2" style="width:100%"></div>
</div>
</div>

<div class="flex gap-6">

<div class="flex-1">
<div id="list" class="space-y-3"></div>
</div>

<div class="w-80 border border-zinc-700 p-3 rounded">
<h2 class="font-bold mb-2">Signal Log</h2>
<div id="log" class="text-sm space-y-2"></div>
</div>

</div>

<script>

const EXCLUDE=['BTCUSDT','ETHUSDT']
let marketData={}
let livePrice={}
let btcReturn=0
let running=false
let timerStarted=false

const RELOAD_INTERVAL=30000
let elapsed=0

async function ignite(){
if(running)return
running=true
await loadBTC()
await loadUniverse()
startWS()
}

async function loadBTC(){
const k=await fetch('https://fapi.binance.com/fapi/v1/klines?symbol=BTCUSDT&interval=1m&limit=2').then(r=>r.json())
btcReturn=(k[1][4]-k[0][1])/k[0][1]
}

async function loadUniverse(){
const tickers=await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr').then(r=>r.json())
const top=tickers.filter(t=>t.symbol.endsWith('USDT')&&!EXCLUDE.includes(t.symbol))
.sort((a,b)=>b.quoteVolume-a.quoteVolume).slice(0,40)

for(let t of top){
await initSymbol(t.symbol)
await new Promise(r=>setTimeout(r,80))
}
}

async function initSymbol(s){
const k=await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${s}&interval=15m&limit=100`).then(r=>r.json())
const oi15=await getOI(s,'15m')
const oi1h=await getOI(s,'1h')
const funding=await getFunding(s)
marketData[s]={klines:k,oi15,oi1h,funding}
}

async function refreshSymbol(s){
const k=await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${s}&interval=15m&limit=100`).then(r=>r.json())
marketData[s].klines=k
marketData[s].oi15=await getOI(s,'15m')
marketData[s].oi1h=await getOI(s,'1h')
marketData[s].funding=await getFunding(s)
}

async function getOI(s,p){
const d=await fetch(`https://fapi.binance.com/futures/data/openInterestHist?symbol=${s}&period=${p}&limit=2`).then(r=>r.json())
if(!d||d.length<2)return 0
return ((d[1].sumOpenInterest-d[0].sumOpenInterest)/d[0].sumOpenInterest)*100
}

async function getFunding(s){
const d=await fetch(`https://fapi.binance.com/fapi/v1/fundingRate?symbol=${s}&limit=1`).then(r=>r.json())
return d.length?parseFloat(d[0].fundingRate):0
}

function startWS(){
const ws=new WebSocket('wss://fstream.binance.com/ws/!ticker@arr')

ws.onmessage=e=>{
JSON.parse(e.data).forEach(m=>{
livePrice[m.s]={price:parseFloat(m.c),vol:parseFloat(m.q)}
})

if(!timerStarted && Object.keys(livePrice).length>0){
timerStarted=true
recalculateAll()
setInterval(recalculateAll,RELOAD_INTERVAL)
startProgressTimer()
}
}
}

async function recalculateAll(){

let result=[]

for(let s in marketData){

if(!livePrice[s]) continue

await refreshSymbol(s)

let base=marketData[s]
let price=livePrice[s].price
let volRatio=(livePrice[s].vol/1440*15)/avgVol(base.klines)

let poc=calcPOC(base.klines)
let vwap=calcVWAP(base.klines)
let slope=calcSlope(base.klines)
let breakout=price>Math.max(...base.klines.slice(-20).map(c=>parseFloat(c[2])))
let rel=((price-base.klines.at(-1)[4])/base.klines.at(-1)[4])-btcReturn

let score=0
let missing=0
function cond(ok,val){ if(ok)score+=val; else missing++ }

cond(base.oi15>0,15)
cond(base.oi1h>0,15)
cond(slope>0,15)
cond(price>poc,10)
cond(price>vwap,10)
cond(rel>0,10)
cond(Math.abs(base.funding)<0.01,5)
cond(volRatio>1.3,10)
cond(breakout,10)

if(score>=50){
result.push({s,price,score,missing})
if(score>=85) addLog(s,score)
}

}

result.sort((a,b)=>b.score-a.score)
render(result)
}

function render(list){

const container=document.getElementById('list')
container.innerHTML=''

if(list.length===0){
container.innerHTML='<div class="text-zinc-500">目前沒有符合條件幣</div>'
return
}

list.forEach(item=>{

let color='bg-zinc-600'
if(item.score>=85) color='bg-emerald-400'
else if(item.score>=70) color='bg-green-500'

let div=document.createElement('div')
div.innerHTML=`
<div class="flex justify-between text-sm mb-1">
<span class="font-bold">${item.s}</span>
<span>${item.score}</span>
</div>
<div class="w-full bg-zinc-800 bar">
<div class="${color} bar" style="width:${item.score}%"></div>
</div>
<div class="text-xs text-zinc-400 mt-1">
差 ${item.missing} 條件
</div>
`
container.appendChild(div)

})
}

function addLog(s,score){
let log=document.getElementById('log')
let div=document.createElement('div')
div.innerHTML=`<span class="text-emerald-400">${s}</span> 強信號 ${score}`
log.prepend(div)
}

function startProgressTimer(){
elapsed=0
setInterval(()=>{
elapsed+=100
let remain=RELOAD_INTERVAL-elapsed
if(remain<0)elapsed=0
let percent=100-(elapsed/RELOAD_INTERVAL*100)
document.getElementById('progressBar').style.width=percent+'%'
document.getElementById('countdown').innerText=Math.ceil(remain/1000)+'s'
},100)
}

function calcVWAP(k){
let pv=0,v=0
k.forEach(c=>{pv+=c[4]*c[5];v+=c[5]})
return pv/v
}

function calcPOC(k){
let bins={}
let prices=k.map(c=>parseFloat(c[4]))
let min=Math.min(...prices)
let max=Math.max(...prices)
let step=(max-min)/20||0.00001
k.forEach(c=>{
let p=parseFloat(c[4]),vol=parseFloat(c[5])
let bin=Math.floor((p-min)/step)*step+min
bins[bin]=(bins[bin]||0)+vol
})
return parseFloat(Object.keys(bins).reduce((a,b)=>bins[a]>bins[b]?a:b))
}

function calcSlope(k){
let closes=k.map(c=>parseFloat(c[4]))
let ema=[]
let m=2/(20+1)
closes.forEach((c,i)=>{ema.push(i?((c-ema[i-1])*m+ema[i-1]):c)})
return ema.at(-1)-ema.at(-5)
}

function avgVol(k){
return k.reduce((a,b)=>a+parseFloat(b[5]),0)/k.length
}

</script>
</body>
</html>
