const BASE = "https://fapi.binance.com";
let symbols = [];
let firstLoad = true;

async function getTopVolumeSymbols(limit){
    const res = await fetch(BASE + "/fapi/v1/ticker/24hr");
    const data = await res.json();

    return data
        .filter(s => s.symbol.endsWith("USDT"))
        .sort((a,b)=> parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
        .slice(35,35+limit) // 排除市值前35
        .map(s=>s.symbol);
}

async function getKlines(symbol, interval, limit=200){
    const res = await fetch(`${BASE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
    return await res.json();
}

function SMA(data, period){
    let sum = 0;
    for(let i=data.length-period;i<data.length;i++){
        sum += parseFloat(data[i][4]);
    }
    return sum/period;
}

function getPOC(data){
    let volumeMap = {};
    data.forEach(c=>{
        let price = parseFloat(c[4]);
        let vol = parseFloat(c[5]);
        volumeMap[Math.round(price*100)/100] = (volumeMap[Math.round(price*100)/100]||0)+vol;
    });
    let max=0, poc=0;
    for(let p in volumeMap){
        if(volumeMap[p]>max){
            max=volumeMap[p];
            poc=parseFloat(p);
        }
    }
    return poc;
}

function getSwingLow(data){
    let lows = data.slice(-20).map(c=>parseFloat(c[3]));
    return Math.min(...lows);
}

function ATR(data){
    let trs=[];
    for(let i=data.length-15;i<data.length;i++){
        let high=parseFloat(data[i][2]);
        let low=parseFloat(data[i][3]);
        trs.push(high-low);
    }
    return trs.reduce((a,b)=>a+b,0)/trs.length;
}

function calculatePosition(entry, stop, risk){
    let riskPerUnit = entry-stop;
    return risk / riskPerUnit;
}

function calculateTP(entry, atr){
    return entry + atr*2;
}

async function scanSymbol(symbol){
    const data = await getKlines(symbol,"15m");
    const data4h = await getKlines(symbol,"4h");

    let price = parseFloat(data[data.length-1][4]);
    let ma25 = SMA(data,25);
    let ma99 = SMA(data,99);
    let poc = getPOC(data4h);
    let swingLow = getSwingLow(data);
    let atr = ATR(data);

    let score=0;
    let strategy=[];

    if(price > ma25 && ma25 > ma99){
        score+=20;
        strategy.push("MA 多頭排列");
    }

    if(price > poc){
        score+=20;
        strategy.push("價格站上4H POC");
    }

    if(price > swingLow){
        score+=10;
        strategy.push("結構未破");
    }

    if(score<50) return null;

    let entry=price;
    let stop=Math.min(swingLow,poc*0.997);
    let risk=parseFloat(document.getElementById("risk").value);
    let position=calculatePosition(entry,stop,risk);
    let tp=calculateTP(entry,atr);

    return {
        symbol,score,entry,stop,tp,position,strategy
    };
}

async function start(){
    document.getElementById("result").innerHTML="掃描中...";
    let limit = firstLoad ? 400 : 100;
    symbols = await getTopVolumeSymbols(limit);
    firstLoad=false;

    let results=[];
    for(let s of symbols){
        let r = await scanSymbol(s);
        if(r) results.push(r);
    }

    results.sort((a,b)=>b.score-a.score);

    let html="";
    results.forEach(r=>{
        html+=`
        <div class="card">
        <b>${r.symbol}</b> 
        <span class="score">評分:${r.score}</span><br>
        Entry: ${r.entry.toFixed(4)}<br>
        Stop: ${r.stop.toFixed(4)}<br>
        TP: ${r.tp.toFixed(4)}<br>
        可開倉位: ${r.position.toFixed(2)}<br>
        <div class="strategy">
        策略: ${r.strategy.join(" | ")}
        </div>
        </div>
        `;
    });

    document.getElementById("result").innerHTML=html || "無符合條件幣種";

    setTimeout(start,30000);
}
