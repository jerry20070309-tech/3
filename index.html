<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>TRIDENT V62 STRATEGY MODE</title>
<style>
body{background:#000;color:#0f0;font-family:monospace;padding:20px}
.card{border:1px solid #222;padding:15px;margin-bottom:15px;background:#0a0a0a}
.tag{display:inline-block;padding:3px 6px;margin:3px;font-size:11px;border-radius:4px}
.on{background:#0f0;color:#000}
.off{background:#400;color:#f55}
input{background:#111;border:1px solid #333;color:#0f0;padding:5px;margin-right:10px;width:100px}
button{background:#0f0;color:#000;border:none;padding:8px 15px;cursor:pointer}
.log{position:fixed;right:20px;top:20px;width:300px;height:400px;border:1px solid #333;padding:10px;overflow:auto;background:#050505}
</style>
</head>
<body>

<h2>TRIDENT V62 â€“ ç­–ç•¥é¡¯ç¤ºç‰ˆ</h2>

å–®ç­†æœ€å¤§è™§æ:
<input id="riskAmount" value="10">

æ§“æ¡¿:
<input id="leverage" value="10">

<button onclick="start()">å•Ÿå‹•</button>

<div id="list"></div>

<div class="log" id="log"><b>Signal Log</b><br><br></div>

<script>

let universe=[]
let prices={}
let alerted=new Set()

async function start(){
await loadUniverse()
scan()
setInterval(scan,30000)
}

async function loadUniverse(){
let res=await fetch("https://fapi.binance.com/fapi/v1/ticker/24hr")
let data=await res.json()

universe=data
.filter(d=>d.symbol.endsWith("USDT"))
.sort((a,b)=>b.quoteVolume-a.quoteVolume)
.slice(0,100)
.map(d=>d.symbol)

connectWS()
}

function connectWS(){
let ws=new WebSocket("wss://fstream.binance.com/ws/!ticker@arr")
ws.onmessage=(e)=>{
let arr=JSON.parse(e.data)
arr.forEach(t=>{
if(universe.includes(t.s)){
prices[t.s]=parseFloat(t.c)
}
})
}
}

async function scan(){

let riskAmount=parseFloat(document.getElementById("riskAmount").value)
let leverage=parseFloat(document.getElementById("leverage").value)

let result=[]

for(let symbol of universe){

let k=await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=50`).then(r=>r.json())

let closes=k.map(x=>parseFloat(x[4]))
let highs=k.map(x=>parseFloat(x[2]))
let lows=k.map(x=>parseFloat(x[3]))
let volumes=k.map(x=>parseFloat(x[5]))

let price=prices[symbol] || closes[closes.length-1]

let ema20=avg(closes.slice(-20))
let ema50=avg(closes.slice(-50))

let trend=ema20>ema50
let breakout=price>Math.max(...highs.slice(-20))
let volumeSpike=volumes[volumes.length-1] > avg(volumes.slice(-20))*1.5

let stop=Math.min(...lows.slice(-5))
let riskDistance=price-stop
if(riskDistance<=0)continue

let storm=3
let tp=price+(riskDistance*storm)

let strategies={
"å¤šé ­æ’åˆ—":trend,
"å€é–“çªç ´":breakout,
"é‡èƒ½æ”¾å¤§":volumeSpike,
"Stormâ‰¥3":storm>=3
}

let score=0
Object.values(strategies).forEach(v=>{if(v)score+=25})

let missing=4-(score/25)

if(score>=75){

let positionSize=riskAmount/riskDistance
let leveragedPosition=positionSize*leverage
let maxReturn=((tp-price)/price)*leverage*100

result.push({
symbol,
price,
stop,
tp,
storm,
maxReturn,
positionSize,
leveragedPosition,
riskAmount,
strategies,
score,
missing
})

if(!alerted.has(symbol)){
logSignal(symbol)
alerted.add(symbol)
}

}

}

render(result)
}

function render(data){
let html=""

data.forEach(d=>{

let tags=""
for(let key in d.strategies){
let v=d.strategies[key]
tags+=`<span class="tag ${v?"on":"off"}">${key}</span>`
}

html+=`
<div class="card">
<b>${d.symbol} | è©•åˆ†: ${d.score}</b><br><br>
${tags}<br>
ç¼ºå°‘ ${d.missing} å€‹æ¢ä»¶<br><br>

Entry: ${d.price.toFixed(4)}<br>
Stop: ${d.stop.toFixed(4)}<br>
TP: ${d.tp.toFixed(4)}<br>
Stormæ¯”: ${d.storm}<br>
æœ€å¤§æ”¶ç›Šç‡: ${d.maxReturn.toFixed(2)}%<br>
å€‰ä½æ•¸é‡: ${d.positionSize.toFixed(2)}<br>
æ§“æ¡¿å¾Œå€‰ä½: ${d.leveragedPosition.toFixed(2)}<br>
å–®ç­†æœ€å¤§è™§æ: ${d.riskAmount}<br>
</div>
`
})

document.getElementById("list").innerHTML=html
}

function logSignal(s){
document.getElementById("log").innerHTML+="ğŸ”¥ STRONG ENTRY "+s+"<br>"
}

function avg(arr){
return arr.reduce((a,b)=>a+b,0)/arr.length
}

</script>
</body>
</html>
