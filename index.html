<script>

//////////////////////////////////////////////////////////////////
// V10 QUANT ENGINE â€“ PART 1
// MARKET ENGINE + DATA ENGINE (PRO VERSION)
//////////////////////////////////////////////////////////////////

//////////////////////////////
// ç³»çµ±æ ¸å¿ƒæ§åˆ¶
//////////////////////////////

const ENGINE = {
    running:false,
    maxActive:20,
    subscribeDelay:350,
    reconnectDelay:3000,
    oiInterval:10000
}

//////////////////////////////
// WebSocket ç®¡ç†
//////////////////////////////

let MARKET_SOCKET=null
let STREAM_SOCKET=null

//////////////////////////////
// è¨‚é–±æ§åˆ¶
//////////////////////////////

let SUBSCRIBE_QUEUE=[]
let ACTIVE_SYMBOLS=new Set()
let PROCESSING_QUEUE=false

//////////////////////////////
// Symbol ç·©å­˜æ± 
//////////////////////////////

let SYMBOL_POOL={}
let OI_POOL={}
let BTC_POOL={
    k15:[],
    k1:[]
}

//////////////////////////////
// æ’é™¤è¦å‰‡
//////////////////////////////

const EXCLUDED_TOP_15=[
"BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT",
"ADAUSDT","DOGEUSDT","AVAXUSDT","TRXUSDT","DOTUSDT",
"MATICUSDT","LTCUSDT","LINKUSDT","BCHUSDT","ATOMUSDT"
]

const METAL_FILTER=["GOLD","SILVER","XAU","XAG"]

//////////////////////////////////////////////////////////////////
// ç³»çµ±å•Ÿåœ
//////////////////////////////////////////////////////////////////

function startEngine(){

    if(ENGINE.running) return

    ENGINE.running=true

    connectMarketSocket()
    connectStreamSocket()

}

function stopEngine(){

    ENGINE.running=false

    if(MARKET_SOCKET) MARKET_SOCKET.close()
    if(STREAM_SOCKET) STREAM_SOCKET.close()

    ACTIVE_SYMBOLS.clear()
    SUBSCRIBE_QUEUE=[]

}

//////////////////////////////////////////////////////////////////
// å¸‚å ´ç›£è½ Socket
//////////////////////////////////////////////////////////////////

function connectMarketSocket(){

    MARKET_SOCKET=new WebSocket("wss://fstream.binance.com/ws/!ticker@arr")

    MARKET_SOCKET.onmessage=(e)=>{

        if(!ENGINE.running) return

        let data=JSON.parse(e.data)

        data.forEach(ticker=>{

            let symbol=ticker.s
            let quoteVol=parseFloat(ticker.q)

            if(!symbol.endsWith("USDT")) return
            if(EXCLUDED_TOP_15.includes(symbol)) return
            if(METAL_FILTER.some(k=>symbol.includes(k))) return
            if(quoteVol<8000000) return

            if(!SYMBOL_POOL[symbol]){
                SYMBOL_POOL[symbol]=createEmptySymbol()
            }

            SYMBOL_POOL[symbol].lastPrice=parseFloat(ticker.c)
            SYMBOL_POOL[symbol].quoteVolume=quoteVol

            if(ACTIVE_SYMBOLS.size<ENGINE.maxActive){
                enqueueSubscribe(symbol)
            }

        })

    }

    MARKET_SOCKET.onclose=()=>{
        if(ENGINE.running){
            setTimeout(connectMarketSocket,ENGINE.reconnectDelay)
        }
    }

}

//////////////////////////////////////////////////////////////////
// Stream Socket
//////////////////////////////////////////////////////////////////

function connectStreamSocket(){

    STREAM_SOCKET=new WebSocket("wss://fstream.binance.com/ws")

    STREAM_SOCKET.onmessage=(e)=>{

        let msg=JSON.parse(e.data)
        if(!msg.stream) return

        let symbol=msg.data.s
        let k=msg.data.k

        if(!SYMBOL_POOL[symbol]) return

        updateKline(symbol,k)

    }

    STREAM_SOCKET.onclose=()=>{
        if(ENGINE.running){
            setTimeout(connectStreamSocket,ENGINE.reconnectDelay)
        }
    }

}

//////////////////////////////////////////////////////////////////
// å»ºç«‹ç©º Symbol çµæ§‹
//////////////////////////////////////////////////////////////////

function createEmptySymbol(){

    return {
        lastPrice:0,
        quoteVolume:0,
        k15:[],
        k1:[],
        atr15:0,
        avgVol:0,
        oi:0,
        prevOI:0,
        state:"IDLE",
        score:0,
        scoreDetails:{},
        support:0,
        stopDistance:0,
        trend:"NEUTRAL",
        momentum:"NEUTRAL",
        pushLock:false,
        exitLock:false
    }

}

//////////////////////////////////////////////////////////////////
// è¨‚é–±ä½‡åˆ—
//////////////////////////////////////////////////////////////////

function enqueueSubscribe(symbol){

    if(ACTIVE_SYMBOLS.has(symbol)) return
    if(SUBSCRIBE_QUEUE.includes(symbol)) return

    SUBSCRIBE_QUEUE.push(symbol)

    if(!PROCESSING_QUEUE){
        processQueue()
    }

}

function processQueue(){

    if(SUBSCRIBE_QUEUE.length===0){
        PROCESSING_QUEUE=false
        return
    }

    PROCESSING_QUEUE=true

    let symbol=SUBSCRIBE_QUEUE.shift()

    ACTIVE_SYMBOLS.add(symbol)

    STREAM_SOCKET.send(JSON.stringify({
        method:"SUBSCRIBE",
        params:[
            `${symbol.toLowerCase()}@kline_15m`,
            `${symbol.toLowerCase()}@kline_1m`
        ],
        id:Date.now()
    }))

    setTimeout(processQueue,ENGINE.subscribeDelay)

}

//////////////////////////////////////////////////////////////////
// Kç·šæ›´æ–°
//////////////////////////////////////////////////////////////////

function updateKline(symbol,k){

    let close=parseFloat(k.c)
    let high=parseFloat(k.h)
    let low=parseFloat(k.l)
    let volume=parseFloat(k.v)

    let obj={
        close,high,low,volume
    }

    if(k.i==="15m"){
        SYMBOL_POOL[symbol].k15.push(obj)
        if(SYMBOL_POOL[symbol].k15.length>200)
            SYMBOL_POOL[symbol].k15.shift()
    }

    if(k.i==="1m"){
        SYMBOL_POOL[symbol].k1.push(obj)
        if(SYMBOL_POOL[symbol].k1.length>200)
            SYMBOL_POOL[symbol].k1.shift()
    }

}

//////////////////////////////////////////////////////////////////
// OI è¼ªè©¢
//////////////////////////////////////////////////////////////////

setInterval(()=>{

    if(!ENGINE.running) return

    ACTIVE_SYMBOLS.forEach(symbol=>{

        fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`)
        .then(r=>r.json())
        .then(d=>{

            let val=parseFloat(d.openInterest)

            SYMBOL_POOL[symbol].prevOI=SYMBOL_POOL[symbol].oi
            SYMBOL_POOL[symbol].oi=val

        })

    })

},ENGINE.oiInterval)

//////////////////////////////////////////////////////////////////
// BTC ç¨ç«‹ç·©å­˜
//////////////////////////////////////////////////////////////////

function cacheBTC(){

    let btc=SYMBOL_POOL["BTCUSDT"]
    if(!btc) return

    BTC_POOL.k15=btc.k15
    BTC_POOL.k1=btc.k1

}

setInterval(cacheBTC,3000)

//////////////////////////////////////////////////////////////////
// ç³»çµ±å¥åº·ç›£æ§
//////////////////////////////////////////////////////////////////

setInterval(()=>{

    if(!ENGINE.running) return

    console.log(
        "Active:",ACTIVE_SYMBOLS.size,
        "Queue:",SUBSCRIBE_QUEUE.length
    )

},10000)

</script>
<script>

//////////////////////////////////////////////////////////////////
// V10 STRATEGY + RISK ENGINE
//////////////////////////////////////////////////////////////////

//////////////////////////////
// å·¥å…·å‡½æ•¸
//////////////////////////////

function MA(data, period){
    if(data.length<period) return 0
    return data.slice(-period).reduce((a,b)=>a+b.close,0)/period
}

function getHigh(data, n){
    if(data.length<n) return 0
    return Math.max(...data.slice(-n).map(c=>c.high))
}

function getLow(data, n){
    if(data.length<n) return 0
    return Math.min(...data.slice(-n).map(c=>c.low))
}

function ATR(data, period){
    if(data.length<period+1) return 0
    let trs=[]
    for(let i=1;i<data.length;i++){
        let high=data[i].high
        let low=data[i].low
        let prev=data[i-1].close
        let tr=Math.max(
            high-low,
            Math.abs(high-prev),
            Math.abs(low-prev)
        )
        trs.push(tr)
    }
    return trs.slice(-period).reduce((a,b)=>a+b,0)/period
}

//////////////////////////////////////////////////////////////////
// ä¸»ç­–ç•¥æ ¸å¿ƒ
//////////////////////////////////////////////////////////////////

function runFullStrategy(symbol){

    let s=SYMBOL_POOL[symbol]
    if(!s) return

    let k15=s.k15
    let k1=s.k1

    if(k15.length<120 || k1.length<60) return

    let price=s.lastPrice

    //////////////////////////
    // å‡ç·šçµæ§‹
    //////////////////////////

    let ma7=MA(k15,7)
    let ma20=MA(k15,20)
    let ma25=MA(k15,25)
    let ma99=MA(k15,99)

    let structureUp=(ma7>ma20 && ma20>ma25 && ma25>ma99)
    let structureSlope=(ma7>MA(k15.slice(0,-1),7))

    //////////////////////////
    // 35çªç ´
    //////////////////////////

    let high35=getHigh(k15,35)
    let breakout=price>high35

    //////////////////////////
    // çˆ†é‡åˆ¤æ–·
    //////////////////////////

    let recent=k15.slice(-35)
    let avgVol=recent.reduce((a,b)=>a+b.volume,0)/35
    let volNow=k15[k15.length-1].volume
    let volRatio=volNow/avgVol

    //////////////////////////
    // POC è¨ˆç®—
    //////////////////////////

    let bucket={}
    recent.forEach(c=>{
        let key=(Math.round(c.close*100)/100).toFixed(2)
        if(!bucket[key]) bucket[key]=0
        bucket[key]+=c.volume
    })

    let poc=Object.keys(bucket)
        .sort((a,b)=>bucket[b]-bucket[a])[0]

    let pocBreak=price>parseFloat(poc)

    //////////////////////////
    // OI å¢é•·æ¨¡å‹
    //////////////////////////

    let oiNow=s.oi
    let oiPrev=s.prevOI||oiNow
    let oiChange=oiPrev>0?((oiNow-oiPrev)/oiPrev*100):0

    let oiStrong=oiChange>3
    let oiBuild=oiChange>1

    //////////////////////////
    // BTC å››å±¤è„«é‰¤
    //////////////////////////

    let btcScore=0

    if(BTC_POOL.k15.length>50){

        let btcHigh=getHigh(BTC_POOL.k15,35)
        let btcPrice=BTC_POOL.k15[BTC_POOL.k15.length-1].close

        if(breakout && btcPrice<btcHigh) btcScore+=10

        let btcATR=ATR(BTC_POOL.k15,14)
        let altATR=ATR(k15,14)

        if(altATR>btcATR) btcScore+=10

        let btcVol=BTC_POOL.k15[BTC_POOL.k15.length-1].volume
        if(volRatio>1.6 && btcVol<avgVol) btcScore+=10

        if(structureUp && btcPrice<MA(BTC_POOL.k15,20))
            btcScore+=10
    }

    //////////////////////////
    // ATR å·®ç•°
    //////////////////////////

    let atr15=ATR(k15,14)
    let atrSpike=atr15>ATR(k15.slice(0,-5),14)

    //////////////////////////
    // 1m æ”¯æ’
    //////////////////////////

    let support=getLow(k1,50)
    let stopDistance=price>0?((price-support)/price*100):0

    //////////////////////////
    // å‹•èƒ½åˆ¤æ–·
    //////////////////////////

    let volDrop=false
    if(k15.length>3){
        let v1=k15[k15.length-1].volume
        let v2=k15[k15.length-2].volume
        if(v1<v2*0.6) volDrop=true
    }

    //////////////////////////
    // åˆ†æ•¸æ‹†è§£
    //////////////////////////

    let scoreDetails={
        breakout:breakout?20:0,
        structure:structureUp?20:0,
        slope:structureSlope?10:0,
        volume:volRatio>2?20:(volRatio>1.6?15:0),
        poc:pocBreak?15:0,
        oi:oiStrong?15:(oiBuild?10:0),
        btc:btcScore,
        atr:atrSpike?10:0
    }

    let total=Object.values(scoreDetails)
        .reduce((a,b)=>a+b,0)

    //////////////////////////
    // ç‹€æ…‹æ©Ÿ
    //////////////////////////

    let state="IDLE"

    if(total>=110) state="STRONG"
    else if(total>=95) state="BREAK"
    else if(total>=80) state="BUILD"
    else if(total>=65) state="RADAR"

    //////////////////////////
    // ä¸»åŠ›æ’¤é€€
    //////////////////////////

    let whaleExit=false
    if(oiChange<-2 && volDrop) whaleExit=true

    //////////////////////////
    // å¯«å›è³‡æ–™æ± 
    //////////////////////////

    s.score=total
    s.scoreDetails=scoreDetails
    s.state=state
    s.support=support
    s.stopDistance=stopDistance
    s.trend=structureUp?"UP":"FLAT"
    s.momentum=volRatio>1.6?"STRONG":"NORMAL"
    s.whaleExit=whaleExit

}

//////////////////////////////////////////////////////////////////
// é€±æœŸåŸ·è¡Œç­–ç•¥
//////////////////////////////////////////////////////////////////

setInterval(()=>{

    if(!ENGINE.running) return

    ACTIVE_SYMBOLS.forEach(symbol=>{
        runFullStrategy(symbol)
    })

},2500)

</script>
<style>
body{background:#050505;color:#d4d4d8;font-family:monospace}
.panel{padding:10px;border-bottom:1px solid #222}
.card{background:#0f0f11;border:1px solid #222;padding:8px;margin:8px}
.STRONG{border:2px solid #22c55e}
.BREAK{border:2px solid #3b82f6}
.BUILD{border:2px solid #f59e0b}
.RADAR{border:2px solid #a855f7}
.IDLE{border:1px solid #222}
.alert{color:#ef4444}
</style>

<div class="panel">
<button onclick="startEngine()">é–‹å§‹æƒæ</button>
<button onclick="stopEngine()">åœæ­¢æƒæ</button>
<span id="engineStatus">OFF</span>
<span id="activeCount"></span>
<br><br>
<input id="tgToken" placeholder="TG BOT TOKEN">
<input id="tgChat" placeholder="CHAT ID">
<input id="searchSymbol" placeholder="æœå°‹å¹£ (ä¾‹: ARBUSDT)">
<button onclick="manualSubscribe()">æœå°‹</button>
</div>

<div class="panel">
<div id="scoreBoard"></div>
</div>

<div id="cards"></div>

<script>

//////////////////////////////////////////////////////////////////
// Telegram æ¨æ’­
//////////////////////////////////////////////////////////////////

async function sendTG(msg){

    let token=document.getElementById("tgToken").value
    let chat=document.getElementById("tgChat").value
    if(!token||!chat) return

    fetch(`https://api.telegram.org/bot${token}/sendMessage`,{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({
            chat_id:chat,
            text:msg
        })
    })

}

//////////////////////////////////////////////////////////////////
// é˜²é‡è¤‡æ¨æ’­æ§åˆ¶
//////////////////////////////////////////////////////////////////

function handlePush(symbol){

    let s=SYMBOL_POOL[symbol]
    if(!s) return

    if(s.state==="STRONG" && !s.pushLock){
        sendTG(`ğŸ”¥ å¼·ä¿¡è™Ÿ ${symbol}
åˆ†æ•¸:${s.score}
æ”¯æ’:${s.support.toFixed(4)}
æ­¢æè·é›¢:${s.stopDistance.toFixed(2)}%`)
        s.pushLock=true
    }

    if(s.whaleExit && !s.exitLock){
        sendTG(`âš  ä¸»åŠ›æ’¤é€€ ${symbol}`)
        s.exitLock=true
    }

}

//////////////////////////////////////////////////////////////////
// è¨˜åˆ†æ¿
//////////////////////////////////////////////////////////////////

function updateScoreBoard(){

    let strong=0,breakN=0,build=0,radar=0

    Object.values(SYMBOL_POOL).forEach(s=>{
        if(s.state==="STRONG") strong++
        if(s.state==="BREAK") breakN++
        if(s.state==="BUILD") build++
        if(s.state==="RADAR") radar++
    })

    document.getElementById("scoreBoard").innerHTML=
        `STRONG:${strong} | BREAK:${breakN} | BUILD:${build} | RADAR:${radar}`

}

//////////////////////////////////////////////////////////////////
// å¡ç‰‡æ¸²æŸ“
//////////////////////////////////////////////////////////////////

function renderCards(){

    let container=document.getElementById("cards")
    container.innerHTML=""

    Object.keys(SYMBOL_POOL).forEach(symbol=>{

        let s=SYMBOL_POOL[symbol]
        if(!s.score) return

        let div=document.createElement("div")
        div.className="card "+s.state

        div.innerHTML=`
<b>${symbol}</b> ç‹€æ…‹:${s.state}<br>
ç¸½åˆ†:${s.score}<br>
çªç ´:${s.scoreDetails.breakout}<br>
çµæ§‹:${s.scoreDetails.structure}<br>
æ–œç‡:${s.scoreDetails.slope}<br>
çˆ†é‡:${s.scoreDetails.volume}<br>
POC:${s.scoreDetails.poc}<br>
OI:${s.scoreDetails.oi}<br>
BTCè„«é‰¤:${s.scoreDetails.btc}<br>
ATR:${s.scoreDetails.atr}<br>
æ”¯æ’:${s.support?.toFixed(4)}<br>
æ­¢æè·é›¢:${s.stopDistance?.toFixed(2)}%<br>
OIå€¼:${s.oi}<br>
${s.whaleExit?'<span class="alert">ä¸»åŠ›æ’¤é€€</span>':''}
`

        container.appendChild(div)

        handlePush(symbol)

    })

    document.getElementById("activeCount").innerText=
        `Active:${ACTIVE_SYMBOLS.size}`

    document.getElementById("engineStatus").innerText=
        ENGINE.running?"ON":"OFF"

}

//////////////////////////////////////////////////////////////////
// æœå°‹å–®å¹£
//////////////////////////////////////////////////////////////////

function manualSubscribe(){

    let s=document.getElementById("searchSymbol").value.toUpperCase()
    if(!s.endsWith("USDT")) s+="USDT"

    if(!SYMBOL_POOL[s]){
        SYMBOL_POOL[s]=createEmptySymbol()
    }

    enqueueSubscribe(s)

}

//////////////////////////////////////////////////////////////////
// UI æ›´æ–°å¾ªç’°
//////////////////////////////////////////////////////////////////

setInterval(()=>{

    if(!ENGINE.running) return

    updateScoreBoard()
    renderCards()

},3000)

</script>
