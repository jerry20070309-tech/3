<script>

//////////////////////////////////////////////////////////////////
// V13 QUANT ENGINE â€“ FIXED 20 + 30 MIN ROTATION
//////////////////////////////////////////////////////////////////

const ENGINE={
    running:false,
    universeSize:20,
    rotationInterval:30*60*1000, // 30åˆ†é˜
    reconnectDelay:3000,
    oiInterval:15000             // OI é™é€Ÿ
}

let STREAM_SOCKET=null
let SYMBOL_POOL={}
let BTC_POOL={k15:[],k1:[],lastPrice:0}
let CURRENT_UNIVERSE=[]

//////////////////////////////////////////////////////////////////
// æ’é™¤å¹£
//////////////////////////////////////////////////////////////////

const EXCLUDED_TOP_15=[
"BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT",
"ADAUSDT","DOGEUSDT","AVAXUSDT","TRXUSDT","DOTUSDT",
"MATICUSDT","LTCUSDT","LINKUSDT","BCHUSDT","ATOMUSDT"
]

//////////////////////////////////////////////////////////////////
// Symbol çµæ§‹
//////////////////////////////////////////////////////////////////

function createEmptySymbol(){
    return{
        lastPrice:0,
        quoteVolume:0,
        k15:[],
        k1:[],
        oi:0,
        prevOI:0,
        oiHistory:[],
        state:"IDLE",
        score:0,
        scoreDetails:{},
        support:0,
        stopDistance:0,
        poc:0,
        whaleExit:false,
        pushLock:false,
        exitLock:false
    }
}

//////////////////////////////////////////////////////////////////
// å•Ÿå‹•å¼•æ“
//////////////////////////////////////////////////////////////////

async function startEngine(){

    if(ENGINE.running) return
    ENGINE.running=true

    await buildUniverse()
    connectStreamSocket()

    setInterval(()=>{
        if(!ENGINE.running) return
        rotateUniverse()
    },ENGINE.rotationInterval)
}

function stopEngine(){
    ENGINE.running=false
    if(STREAM_SOCKET) STREAM_SOCKET.close()
}

//////////////////////////////////////////////////////////////////
// å»ºç«‹ Universe
//////////////////////////////////////////////////////////////////

async function buildUniverse(){

    let tickers=await fetch(
        "https://fapi.binance.com/fapi/v1/ticker/24hr"
    ).then(r=>r.json())

    let filtered=tickers
        .filter(t=>t.symbol.endsWith("USDT"))
        .filter(t=>!EXCLUDED_TOP_15.includes(t.symbol))
        .filter(t=>parseFloat(t.quoteVolume)>2000000)
        .sort((a,b)=>parseFloat(b.quoteVolume)-parseFloat(a.quoteVolume))
        .slice(0,ENGINE.universeSize)

    CURRENT_UNIVERSE=filtered.map(t=>t.symbol)

    CURRENT_UNIVERSE.forEach(s=>{
        if(!SYMBOL_POOL[s])
            SYMBOL_POOL[s]=createEmptySymbol()
    })
}

//////////////////////////////////////////////////////////////////
// 30 åˆ†é˜è¼ªæ›¿
//////////////////////////////////////////////////////////////////

async function rotateUniverse(){

    if(STREAM_SOCKET) STREAM_SOCKET.close()

    CURRENT_UNIVERSE=[]
    await buildUniverse()
    connectStreamSocket()
}

//////////////////////////////////////////////////////////////////
// å»ºç«‹å›ºå®š Stream
//////////////////////////////////////////////////////////////////

function connectStreamSocket(){

    let streams=["btcusdt@kline_15m","btcusdt@kline_1m"]

    CURRENT_UNIVERSE.forEach(s=>{
        streams.push(`${s.toLowerCase()}@kline_15m`)
        streams.push(`${s.toLowerCase()}@kline_1m`)
    })

    let url=
    "wss://fstream.binance.com/stream?streams="+
    streams.join("/")

    STREAM_SOCKET=new WebSocket(url)

    STREAM_SOCKET.onmessage=(e)=>{

        let msg=JSON.parse(e.data)
        let data=msg.data
        let s=data.s
        let k=data.k

        let obj={
            close:parseFloat(k.c),
            high:parseFloat(k.h),
            low:parseFloat(k.l),
            volume:parseFloat(k.v)
        }

        if(s==="BTCUSDT"){

            BTC_POOL.lastPrice=parseFloat(k.c)

            if(k.i==="15m"){
                BTC_POOL.k15.push(obj)
                if(BTC_POOL.k15.length>300)
                    BTC_POOL.k15.shift()
            }

            if(k.i==="1m"){
                BTC_POOL.k1.push(obj)
                if(BTC_POOL.k1.length>300)
                    BTC_POOL.k1.shift()
            }

            return
        }

        if(!SYMBOL_POOL[s]) return

        SYMBOL_POOL[s].lastPrice=parseFloat(k.c)

        if(k.i==="15m"){
            SYMBOL_POOL[s].k15.push(obj)
            if(SYMBOL_POOL[s].k15.length>300)
                SYMBOL_POOL[s].k15.shift()
        }

        if(k.i==="1m"){
            SYMBOL_POOL[s].k1.push(obj)
            if(SYMBOL_POOL[s].k1.length>300)
                SYMBOL_POOL[s].k1.shift()
        }
    }

    STREAM_SOCKET.onclose=()=>{
        if(ENGINE.running)
            setTimeout(connectStreamSocket,ENGINE.reconnectDelay)
    }
}

//////////////////////////////////////////////////////////////////
// OI æ…¢é€Ÿè¼ªè©¢
//////////////////////////////////////////////////////////////////

setInterval(()=>{
    if(!ENGINE.running) return

    CURRENT_UNIVERSE.forEach(symbol=>{
        fetch(
        `https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`
        )
        .then(r=>r.json())
        .then(d=>{
            let s=SYMBOL_POOL[symbol]
            s.prevOI=s.oi
            s.oi=parseFloat(d.openInterest)
            s.oiHistory.push(s.oi)
            if(s.oiHistory.length>30)
                s.oiHistory.shift()
        })
    })

},ENGINE.oiInterval)

</script>
<script>

//////////////////////////////////////////////////////////////////
// V13 STRATEGY ENGINE â€“ FULL FOUR LAYER (ROTATION COMPATIBLE)
//////////////////////////////////////////////////////////////////

////////////////////////////
// åŸºç¤å·¥å…·
////////////////////////////

function MA(data,n){
    if(data.length<n) return 0
    return data.slice(-n).reduce((a,b)=>a+b.close,0)/n
}

function getHigh(data,n){
    if(data.length<n) return 0
    return Math.max(...data.slice(-n).map(c=>c.high))
}

function getLow(data,n){
    if(data.length<n) return 0
    return Math.min(...data.slice(-n).map(c=>c.low))
}

function ATR(data,n){
    if(data.length<n+1) return 0
    let trs=[]
    for(let i=1;i<data.length;i++){
        let high=data[i].high
        let low=data[i].low
        let prev=data[i-1].close
        let tr=Math.max(
            high-low,
            Math.abs(high-prev),
            Math.abs(low-prev)
        )
        trs.push(tr)
    }
    return trs.slice(-n).reduce((a,b)=>a+b,0)/n
}

//////////////////////////////////////////////////////////////////
// ä¸»ç­–ç•¥
//////////////////////////////////////////////////////////////////

function runFullStrategy(symbol){

    let s=SYMBOL_POOL[symbol]
    if(!s) return

    if(s.k15.length<120 || s.k1.length<60) return
    if(BTC_POOL.k15.length<120) return

    let price=s.lastPrice

    //////////////////////////////////////////////////////////////
    // ç¬¬ä¸€å±¤ï¼šè¶¨å‹¢çµæ§‹
    //////////////////////////////////////////////////////////////

    let ma7=MA(s.k15,7)
    let ma20=MA(s.k15,20)
    let ma25=MA(s.k15,25)
    let ma99=MA(s.k15,99)

    let structureStrong=(ma7>ma20 && ma20>ma25 && ma25>ma99)
    let structureBuild=(ma7>ma20 && ma20>ma25)
    let slopeUp=ma7>MA(s.k15.slice(0,-1),7)

    //////////////////////////////////////////////////////////////
    // ç¬¬äºŒå±¤ï¼šçªç ´å±¤
    //////////////////////////////////////////////////////////////

    let high35=getHigh(s.k15,35)
    let breakout=price>high35
    let nearBreak=price>high35*0.995

    //////////////////////////////////////////////////////////////
    // ç¬¬ä¸‰å±¤ï¼šå‹•èƒ½å±¤
    //////////////////////////////////////////////////////////////

    let recent=s.k15.slice(-35)
    let avgVol=recent.reduce((a,b)=>a+b.volume,0)/35
    let volNow=s.k15[s.k15.length-1].volume
    let volRatio=volNow/avgVol

    let atr15=ATR(s.k15,14)
    let atrPast=ATR(s.k15.slice(0,-5),14)
    let atrExpand=atr15>atrPast

    let btcATR=ATR(BTC_POOL.k15,14)
    let atrDecouple=atr15>btcATR*1.2

    //////////////////////////////////////////////////////////////
    // ç¬¬å››å±¤ï¼šOI ä¸»åŠ›å±¤
    //////////////////////////////////////////////////////////////

    let oiNow=s.oi
    let oiPrev=s.prevOI||oiNow
    let oiChange=oiPrev>0?((oiNow-oiPrev)/oiPrev*100):0

    let oiBuild=oiChange>0.5
    let oiStrong=oiChange>2

    let oiTrendUp=false
    if(s.oiHistory.length>=5){
        let recentOI=s.oiHistory.slice(-5)
        oiTrendUp=recentOI[4]>recentOI[0]
    }

    //////////////////////////////////////////////////////////////
    // ç¬¬äº”å±¤ï¼šBTC è„«é‰¤
    //////////////////////////////////////////////////////////////

    let btcPrice=BTC_POOL.lastPrice
    let btcHigh35=getHigh(BTC_POOL.k15,35)

    let priceDecouple=(price>high35 && btcPrice<btcHigh35)

    let btcMA7=MA(BTC_POOL.k15,7)
    let btcMA20=MA(BTC_POOL.k15,20)
    let btcStructure=(btcMA7>btcMA20)

    let structureDecouple=(structureStrong && !btcStructure)

    let volumeDecouple=(volRatio>1.5 && atrDecouple)

    //////////////////////////////////////////////////////////////
    // ç¬¬å…­å±¤ï¼šPOC
    //////////////////////////////////////////////////////////////

    let bucket={}
    recent.forEach(c=>{
        let key=(Math.round(c.close*100)/100).toFixed(2)
        if(!bucket[key]) bucket[key]=0
        bucket[key]+=c.volume
    })

    let poc=Object.keys(bucket)
        .sort((a,b)=>bucket[b]-bucket[a])[0]

    s.poc=parseFloat(poc)
    let pocBreak=price>s.poc

    //////////////////////////////////////////////////////////////
    // ç¬¬ä¸ƒå±¤ï¼šé¢¨æ§
    //////////////////////////////////////////////////////////////

    let support=getLow(s.k1,50)
    let stopDistance=price>0?((price-support)/price*100):0

    s.support=support
    s.stopDistance=stopDistance

    //////////////////////////////////////////////////////////////
    // ä¸»åŠ›æ’¤é€€æ¨¡å‹
    //////////////////////////////////////////////////////////////

    let whaleExit=false
    if(oiChange<-1.5 && volRatio<1){
        whaleExit=true
    }

    //////////////////////////////////////////////////////////////
    // åˆ†æ•¸ç³»çµ±ï¼ˆå®Œæ•´å››å±¤ï¼‰
    //////////////////////////////////////////////////////////////

    let scoreDetails={

        structure:structureStrong?20:(structureBuild?12:0),
        slope:slopeUp?8:0,

        breakout:breakout?20:(nearBreak?15:0),

        volume:volRatio>2?20:(volRatio>1.5?15:(volRatio>1.2?8:0)),

        atr:atrExpand?8:0,
        atrDecouple:atrDecouple?8:0,

        oi:oiStrong?15:(oiBuild?8:0),
        oiTrend:oiTrendUp?8:0,

        priceDecouple:priceDecouple?10:0,
        structureDecouple:structureDecouple?8:0,
        volumeDecouple:volumeDecouple?8:0,

        poc:pocBreak?8:0
    }

    let total=Object.values(scoreDetails)
        .reduce((a,b)=>a+b,0)

    //////////////////////////////////////////////////////////////
    // ç‹€æ…‹æ©Ÿ
    //////////////////////////////////////////////////////////////

    let state="IDLE"

    if(total>=110) state="STRONG"
    else if(total>=95) state="BREAK"
    else if(total>=80) state="BUILD"
    else if(total>=65) state="RADAR"

    //////////////////////////////////////////////////////////////

    s.score=total
    s.scoreDetails=scoreDetails
    s.state=state
    s.whaleExit=whaleExit
}

//////////////////////////////////////////////////////////////////
// å®šæœŸåŸ·è¡Œç­–ç•¥
//////////////////////////////////////////////////////////////////

setInterval(()=>{
    if(!ENGINE.running) return

    CURRENT_UNIVERSE.forEach(symbol=>{
        runFullStrategy(symbol)
    })

},2500)

</script>
<style>
body{background:#050505;color:#d4d4d8;font-family:monospace}
.panel{padding:12px;border-bottom:1px solid #222}
.card{background:#0f0f11;border:1px solid #222;padding:10px;margin:10px}
.STRONG{border:2px solid #22c55e}
.BREAK{border:2px solid #3b82f6}
.BUILD{border:2px solid #f59e0b}
.RADAR{border:2px solid #a855f7}
.IDLE{border:1px solid #222}
.alert{color:#ef4444}
.small{font-size:12px;color:#aaa}
</style>

<div class="panel">
<button onclick="startEngine()">é–‹å§‹æƒæ</button>
<button onclick="stopEngine()">åœæ­¢æƒæ</button>
<span id="engineStatus">OFF</span>
<br><br>

<input id="tgToken" placeholder="TG BOT TOKEN">
<input id="tgChat" placeholder="CHAT ID">
<button onclick="testPush()">æ¸¬è©¦æ¨æ’­</button>

<br><br>
<div>ç•¶å‰ç›£æ§å¹£æ•¸: <span id="universeCount">0</span></div>
<div>ä¸‹æ¬¡è¼ªæ›¿å€’æ•¸: <span id="rotationTimer">--</span></div>
</div>

<div class="panel">
<div id="scoreBoard"></div>
</div>

<div id="cards"></div>

<script>

//////////////////////////////////////////////////////////////////
// Telegram
//////////////////////////////////////////////////////////////////

async function sendTG(msg){
    let token=document.getElementById("tgToken").value.trim()
    let chat=document.getElementById("tgChat").value.trim()
    if(!token||!chat) return

    fetch(`https://api.telegram.org/bot${token}/sendMessage`,{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({
            chat_id:chat,
            text:msg
        })
    })
}

function testPush(){
    sendTG("âœ… V13 å›ºå®š20å¹£è¼ªæ›¿ç‰ˆ æ¸¬è©¦æˆåŠŸ")
}

//////////////////////////////////////////////////////////////////
// æ¨æ’­æ§åˆ¶
//////////////////////////////////////////////////////////////////

function handlePush(symbol){

    let s=SYMBOL_POOL[symbol]
    if(!s) return

    if(s.stopDistance<1.0) return

    if(s.state==="STRONG" && !s.pushLock){

        sendTG(
`ğŸ”¥ STRONG ${symbol}
ç¸½åˆ†:${s.score}

çµæ§‹:${s.scoreDetails.structure}
æ–œç‡:${s.scoreDetails.slope}
çªç ´:${s.scoreDetails.breakout}
çˆ†é‡:${s.scoreDetails.volume}
ATR:${s.scoreDetails.atr}
ATRè„«é‰¤:${s.scoreDetails.atrDecouple}
OI:${s.scoreDetails.oi}
OIè¶¨å‹¢:${s.scoreDetails.oiTrend}
åƒ¹æ ¼è„«é‰¤:${s.scoreDetails.priceDecouple}
çµæ§‹è„«é‰¤:${s.scoreDetails.structureDecouple}
é‡èƒ½è„«é‰¤:${s.scoreDetails.volumeDecouple}
POC:${s.scoreDetails.poc}

æ”¯æ’:${s.support?.toFixed(4)}
æ­¢æè·é›¢:${s.stopDistance?.toFixed(2)}%`
        )

        s.pushLock=true
    }

    if(s.whaleExit && !s.exitLock){
        sendTG(`âš  EXIT ${symbol} ä¸»åŠ›æ’¤é€€`)
        s.exitLock=true
    }
}

//////////////////////////////////////////////////////////////////
// è¨˜åˆ†æ¿
//////////////////////////////////////////////////////////////////

function updateScoreBoard(){

    let strong=0,breakN=0,build=0,radar=0

    CURRENT_UNIVERSE.forEach(sym=>{
        let s=SYMBOL_POOL[sym]
        if(!s) return
        if(s.state==="STRONG") strong++
        if(s.state==="BREAK") breakN++
        if(s.state==="BUILD") build++
        if(s.state==="RADAR") radar++
    })

    document.getElementById("scoreBoard").innerHTML=
        `STRONG:${strong} | BREAK:${breakN} | BUILD:${build} | RADAR:${radar}`
}

//////////////////////////////////////////////////////////////////
// å¡ç‰‡é¡¯ç¤º
//////////////////////////////////////////////////////////////////

function renderCards(){

    let container=document.getElementById("cards")
    container.innerHTML=""

    CURRENT_UNIVERSE.forEach(symbol=>{

        let s=SYMBOL_POOL[symbol]
        if(!s || !s.score) return

        let div=document.createElement("div")
        div.className="card "+s.state

        div.innerHTML=`
<b>${symbol}</b> ç‹€æ…‹:${s.state}<br>
ç¸½åˆ†:${s.score}<br>
<div class="small">
çµæ§‹:${s.scoreDetails.structure}
æ–œç‡:${s.scoreDetails.slope}
çªç ´:${s.scoreDetails.breakout}
çˆ†é‡:${s.scoreDetails.volume}
ATR:${s.scoreDetails.atr}
ATRè„«é‰¤:${s.scoreDetails.atrDecouple}
OI:${s.scoreDetails.oi}
OIè¶¨å‹¢:${s.scoreDetails.oiTrend}
åƒ¹æ ¼è„«é‰¤:${s.scoreDetails.priceDecouple}
çµæ§‹è„«é‰¤:${s.scoreDetails.structureDecouple}
é‡èƒ½è„«é‰¤:${s.scoreDetails.volumeDecouple}
POC:${s.scoreDetails.poc}
</div>
æ”¯æ’:${s.support?.toFixed(4)}<br>
æ­¢æè·é›¢:${s.stopDistance?.toFixed(2)}%<br>
${s.whaleExit?'<span class="alert">ä¸»åŠ›æ’¤é€€</span>':''}
`

        container.appendChild(div)
        handlePush(symbol)
    })

    document.getElementById("universeCount").innerText=
        CURRENT_UNIVERSE.length

    document.getElementById("engineStatus").innerText=
        ENGINE.running?"ON":"OFF"
}

//////////////////////////////////////////////////////////////////
// è¼ªæ›¿å€’æ•¸
//////////////////////////////////////////////////////////////////

let rotationLeft=ENGINE.rotationInterval

setInterval(()=>{
    if(!ENGINE.running) return
    rotationLeft-=1000
    if(rotationLeft<=0) rotationLeft=ENGINE.rotationInterval

    let min=Math.floor(rotationLeft/60000)
    let sec=Math.floor((rotationLeft%60000)/1000)

    document.getElementById("rotationTimer").innerText=
        `${min}m ${sec}s`

},1000)

//////////////////////////////////////////////////////////////////
// UI æ›´æ–°
//////////////////////////////////////////////////////////////////

setInterval(()=>{
    if(!ENGINE.running) return
    updateScoreBoard()
    renderCards()
},3000)

</script>
