<script>

//////////////////////////////////////////////////////////////////
// V12 QUANT ENGINE â€“ PART 1
// MARKET + DATA ENGINE (FULL STRUCTURE VERSION)
//////////////////////////////////////////////////////////////////

const ENGINE={
    running:false,
    maxActive:15,              // ç›£æ§å¹£æ•¸ä¸Šé™
    subscribeDelay:800,        // è¨‚é–±ç¯€æµ
    reconnectDelay:600,
    oiInterval:12000            // OI è¼ªè©¢é–“éš”
}

let MARKET_SOCKET=null
let STREAM_SOCKET=null

let SUBSCRIBE_QUEUE=[]
let ACTIVE_SYMBOLS=new Set()
let PROCESSING_QUEUE=false

let SYMBOL_POOL={}
let BTC_POOL={
    k15:[],
    k1:[],
    lastPrice:0
}

//////////////////////////////////////////////////////////////////
// æ’é™¤å¹£ç¨®
//////////////////////////////////////////////////////////////////

const EXCLUDED_TOP_15=[
"BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT",
"ADAUSDT","DOGEUSDT","AVAXUSDT","TRXUSDT","DOTUSDT",
"MATICUSDT","LTCUSDT","LINKUSDT","BCHUSDT","ATOMUSDT"
]

//////////////////////////////////////////////////////////////////
// Symbol çµæ§‹
//////////////////////////////////////////////////////////////////

function createEmptySymbol(){
    return{
        lastPrice:0,
        quoteVolume:0,

        k15:[],
        k1:[],

        oi:0,
        prevOI:0,
        oiHistory:[],

        state:"IDLE",
        score:0,
        scoreDetails:{},

        support:0,
        stopDistance:0,

        breakoutLevel:0,
        poc:0,

        pushLock:false,
        exitLock:false,

        whaleExit:false
    }
}

//////////////////////////////////////////////////////////////////
// å¼•æ“æ§åˆ¶
//////////////////////////////////////////////////////////////////

function startEngine(){
    if(ENGINE.running) return
    ENGINE.running=true
    connectMarketSocket()
    connectStreamSocket()
}

function stopEngine(){
    ENGINE.running=false

    if(MARKET_SOCKET) MARKET_SOCKET.close()
    if(STREAM_SOCKET) STREAM_SOCKET.close()

    ACTIVE_SYMBOLS.clear()
    SUBSCRIBE_QUEUE=[]
}

//////////////////////////////////////////////////////////////////
// å¸‚å ´ç¸½ç›£è½
//////////////////////////////////////////////////////////////////

function connectMarketSocket(){

    MARKET_SOCKET=new WebSocket("wss://fstream.binance.com/ws/!ticker@arr")

    MARKET_SOCKET.onmessage=(e)=>{

        if(!ENGINE.running) return

        let data=JSON.parse(e.data)

        data.forEach(t=>{

            let symbol=t.s
            let quoteVol=parseFloat(t.q)

            if(!symbol.endsWith("USDT")) return
            if(EXCLUDED_TOP_15.includes(symbol)) return

            // ğŸ”¥ å•Ÿå‹•æ•æ‰ç‰ˆæœ¬æˆäº¤é‡é–€æª»ï¼ˆä¸éä½ï¼‰
            if(quoteVol<2000000) return

            if(!SYMBOL_POOL[symbol]){
                SYMBOL_POOL[symbol]=createEmptySymbol()
            }

            SYMBOL_POOL[symbol].lastPrice=parseFloat(t.c)
            SYMBOL_POOL[symbol].quoteVolume=quoteVol

            if(ACTIVE_SYMBOLS.size<ENGINE.maxActive){
                enqueueSubscribe(symbol)
            }

        })
    }

    MARKET_SOCKET.onclose=()=>{
        if(ENGINE.running)
            setTimeout(connectMarketSocket,ENGINE.reconnectDelay)
    }
}

//////////////////////////////////////////////////////////////////
// Kç·š + Stream Socket
//////////////////////////////////////////////////////////////////

function connectStreamSocket(){

    STREAM_SOCKET=new WebSocket("wss://fstream.binance.com/ws")

    STREAM_SOCKET.onmessage=(e)=>{

        let msg=JSON.parse(e.data)
        if(!msg.stream) return

        let s=msg.data.s
        let k=msg.data.k

        let obj={
            close:parseFloat(k.c),
            high:parseFloat(k.h),
            low:parseFloat(k.l),
            volume:parseFloat(k.v)
        }

        // BTC ç‰¹æ®Šæ± 
        if(s==="BTCUSDT"){

            BTC_POOL.lastPrice=parseFloat(k.c)

            if(k.i==="15m"){
                BTC_POOL.k15.push(obj)
                if(BTC_POOL.k15.length>300)
                    BTC_POOL.k15.shift()
            }

            if(k.i==="1m"){
                BTC_POOL.k1.push(obj)
                if(BTC_POOL.k1.length>300)
                    BTC_POOL.k1.shift()
            }

            return
        }

        if(!SYMBOL_POOL[s]) return

        if(k.i==="15m"){
            SYMBOL_POOL[s].k15.push(obj)
            if(SYMBOL_POOL[s].k15.length>300)
                SYMBOL_POOL[s].k15.shift()
        }

        if(k.i==="1m"){
            SYMBOL_POOL[s].k1.push(obj)
            if(SYMBOL_POOL[s].k1.length>300)
                SYMBOL_POOL[s].k1.shift()
        }
    }

    STREAM_SOCKET.onopen=()=>{

        // è¨‚é–± BTC
        STREAM_SOCKET.send(JSON.stringify({
            method:"SUBSCRIBE",
            params:[
                "btcusdt@kline_15m",
                "btcusdt@kline_1m"
            ],
            id:1
        }))
    }

    STREAM_SOCKET.onclose=()=>{
        if(ENGINE.running)
            setTimeout(connectStreamSocket,ENGINE.reconnectDelay)
    }
}

//////////////////////////////////////////////////////////////////
// è¨‚é–±ä½‡åˆ—æ§åˆ¶
//////////////////////////////////////////////////////////////////

function enqueueSubscribe(symbol){

    if(ACTIVE_SYMBOLS.has(symbol)) return
    if(SUBSCRIBE_QUEUE.includes(symbol)) return

    SUBSCRIBE_QUEUE.push(symbol)

    if(!PROCESSING_QUEUE)
        processQueue()
}

function processQueue(){

    if(SUBSCRIBE_QUEUE.length===0){
        PROCESSING_QUEUE=false
        return
    }

    PROCESSING_QUEUE=true

    let symbol=SUBSCRIBE_QUEUE.shift()
    ACTIVE_SYMBOLS.add(symbol)

    STREAM_SOCKET.send(JSON.stringify({
        method:"SUBSCRIBE",
        params:[
            `${symbol.toLowerCase()}@kline_15m`,
            `${symbol.toLowerCase()}@kline_1m`
        ],
        id:Date.now()
    }))

    setTimeout(processQueue,ENGINE.subscribeDelay)
}

//////////////////////////////////////////////////////////////////
// OI è¼ªè©¢
//////////////////////////////////////////////////////////////////

setInterval(()=>{

    if(!ENGINE.running) return

    ACTIVE_SYMBOLS.forEach(symbol=>{

        fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`)
        .then(r=>r.json())
        .then(d=>{

            let s=SYMBOL_POOL[symbol]

            s.prevOI=s.oi
            s.oi=parseFloat(d.openInterest)

            s.oiHistory.push(s.oi)
            if(s.oiHistory.length>30)
                s.oiHistory.shift()

        })

    })

},ENGINE.oiInterval)

</script>
<script>

//////////////////////////////////////////////////////////////////
// V12 STRATEGY ENGINE â€“ FULL FOUR LAYER MODEL
//////////////////////////////////////////////////////////////////

//////////////////////////
// åŸºç¤å·¥å…·
//////////////////////////

function MA(data,n){
    if(data.length<n) return 0
    return data.slice(-n).reduce((a,b)=>a+b.close,0)/n
}

function getHigh(data,n){
    if(data.length<n) return 0
    return Math.max(...data.slice(-n).map(c=>c.high))
}

function getLow(data,n){
    if(data.length<n) return 0
    return Math.min(...data.slice(-n).map(c=>c.low))
}

function ATR(data,n){
    if(data.length<n+1) return 0
    let trs=[]
    for(let i=1;i<data.length;i++){
        let high=data[i].high
        let low=data[i].low
        let prev=data[i-1].close
        let tr=Math.max(
            high-low,
            Math.abs(high-prev),
            Math.abs(low-prev)
        )
        trs.push(tr)
    }
    return trs.slice(-n).reduce((a,b)=>a+b,0)/n
}

//////////////////////////////////////////////////////////////////
// ä¸»ç­–ç•¥
//////////////////////////////////////////////////////////////////

function runFullStrategy(symbol){

    let s=SYMBOL_POOL[symbol]
    if(!s) return

    if(s.k15.length<120 || s.k1.length<60) return
    if(BTC_POOL.k15.length<120) return

    let price=s.lastPrice

    //////////////////////////////////////////////////////////////
    // ç¬¬ä¸€å±¤ï¼šçµæ§‹å±¤
    //////////////////////////////////////////////////////////////

    let ma7=MA(s.k15,7)
    let ma20=MA(s.k15,20)
    let ma25=MA(s.k15,25)
    let ma99=MA(s.k15,99)

    let structureStrong=(ma7>ma20 && ma20>ma25 && ma25>ma99)
    let structureBuild=(ma7>ma20 && ma20>ma25)

    let slopeUp=ma7>MA(s.k15.slice(0,-1),7)

    //////////////////////////////////////////////////////////////
    // ç¬¬äºŒå±¤ï¼šçªç ´å±¤
    //////////////////////////////////////////////////////////////

    let high35=getHigh(s.k15,35)
    let breakout=price>high35
    let nearBreak=price>high35*0.995

    //////////////////////////////////////////////////////////////
    // ç¬¬ä¸‰å±¤ï¼šå‹•èƒ½å±¤
    //////////////////////////////////////////////////////////////

    let recent=s.k15.slice(-35)
    let avgVol=recent.reduce((a,b)=>a+b.volume,0)/35
    let volNow=s.k15[s.k15.length-1].volume
    let volRatio=volNow/avgVol

    let atr15=ATR(s.k15,14)
    let btcATR=ATR(BTC_POOL.k15,14)

    let atrExpand=atr15>ATR(s.k15.slice(0,-5),14)
    let atrDivergence=atr15>btcATR*1.2

    //////////////////////////////////////////////////////////////
    // ç¬¬å››å±¤ï¼šä¸»åŠ› OI å±¤
    //////////////////////////////////////////////////////////////

    let oiNow=s.oi
    let oiPrev=s.prevOI||oiNow
    let oiChange=oiPrev>0?((oiNow-oiPrev)/oiPrev*100):0

    let oiBuild=oiChange>0.5
    let oiStrong=oiChange>2

    let oiTrendUp=false
    if(s.oiHistory.length>=5){
        let recentOI=s.oiHistory.slice(-5)
        oiTrendUp=recentOI[4]>recentOI[0]
    }

    //////////////////////////////////////////////////////////////
    // ç¬¬äº”å±¤ï¼šBTC è„«é‰¤å±¤ï¼ˆå››å±¤ï¼‰
    //////////////////////////////////////////////////////////////

    let btcPrice=BTC_POOL.lastPrice
    let btcHigh35=getHigh(BTC_POOL.k15,35)

    let priceDecouple=(price>high35 && btcPrice<btcHigh35)

    let btcMA7=MA(BTC_POOL.k15,7)
    let btcMA20=MA(BTC_POOL.k15,20)
    let btcStructure=(btcMA7>btcMA20)

    let structureDecouple=(structureStrong && !btcStructure)

    let volumeDecouple=volRatio>1.5 && atrDivergence

    let atrDecouple=atrDivergence

    //////////////////////////////////////////////////////////////
    // ç¬¬å…­å±¤ï¼šPOC
    //////////////////////////////////////////////////////////////

    let bucket={}
    recent.forEach(c=>{
        let key=(Math.round(c.close*100)/100).toFixed(2)
        if(!bucket[key]) bucket[key]=0
        bucket[key]+=c.volume
    })

    let poc=Object.keys(bucket)
        .sort((a,b)=>bucket[b]-bucket[a])[0]

    s.poc=parseFloat(poc)

    let pocBreak=price>s.poc

    //////////////////////////////////////////////////////////////
    // ç¬¬ä¸ƒå±¤ï¼šé¢¨æ§å±¤
    //////////////////////////////////////////////////////////////

    let support=getLow(s.k1,50)
    let stopDistance=price>0?((price-support)/price*100):0

    s.support=support
    s.stopDistance=stopDistance

    //////////////////////////////////////////////////////////////
    // ä¸»åŠ›æ’¤é€€æ¨¡å‹
    //////////////////////////////////////////////////////////////

    let whaleExit=false
    if(oiChange<-1.5 && volRatio<1){
        whaleExit=true
    }

    //////////////////////////////////////////////////////////////
    // åˆ†æ•¸ç³»çµ±ï¼ˆå®Œæ•´å››å±¤ï¼‰
    //////////////////////////////////////////////////////////////

    let scoreDetails={

        structure:structureStrong?20:(structureBuild?12:0),
        slope:slopeUp?8:0,

        breakout:breakout?20:(nearBreak?15:0),

        volume:volRatio>2?20:(volRatio>1.5?15:(volRatio>1.2?8:0)),

        atr:atrExpand?8:0,
        atrDecouple:atrDecouple?8:0,

        oi:oiStrong?15:(oiBuild?8:0),
        oiTrend:oiTrendUp?8:0,

        priceDecouple:priceDecouple?10:0,
        structureDecouple:structureDecouple?8:0,
        volumeDecouple:volumeDecouple?8:0,

        poc:pocBreak?8:0
    }

    let total=Object.values(scoreDetails)
        .reduce((a,b)=>a+b,0)

    //////////////////////////////////////////////////////////////
    // ç‹€æ…‹æ©Ÿ
    //////////////////////////////////////////////////////////////

    let state="IDLE"

    if(total>=65) state="STRONG"
    else if(total>=95) state="BREAK"
    else if(total>=80) state="BUILD"
    else if(total>=65) state="RADAR"

    //////////////////////////////////////////////////////////////

    s.score=total
    s.scoreDetails=scoreDetails
    s.state=state
    s.whaleExit=whaleExit
}

//////////////////////////////////////////////////////////////////
// é€±æœŸåŸ·è¡Œ
//////////////////////////////////////////////////////////////////

setInterval(()=>{
    if(!ENGINE.running) return
    ACTIVE_SYMBOLS.forEach(symbol=>{
        runFullStrategy(symbol)
    })
},2000)

</script>
<style>
body{background:#050505;color:#d4d4d8;font-family:monospace}
.panel{padding:12px;border-bottom:1px solid #222}
.card{background:#0f0f11;border:1px solid #222;padding:10px;margin:10px}
.STRONG{border:2px solid #22c55e}
.BREAK{border:2px solid #3b82f6}
.BUILD{border:2px solid #f59e0b}
.RADAR{border:2px solid #a855f7}
.IDLE{border:1px solid #222}
.alert{color:#ef4444}
.small{font-size:12px;color:#aaa}
</style>

<div class="panel">
<button onclick="startEngine()">é–‹å§‹æƒæ</button>
<button onclick="stopEngine()">åœæ­¢æƒæ</button>
<span id="engineStatus">OFF</span>
<span id="activeCount"></span>
<br><br>

<input id="tgToken" placeholder="TG BOT TOKEN">
<input id="tgChat" placeholder="CHAT ID">
<button onclick="testPush()">æ¸¬è©¦æ¨æ’­</button>

<br><br>

<input id="searchSymbol" placeholder="æœå°‹å¹£ (ä¾‹: ARBUSDT)">
<button onclick="manualSubscribe()">æœå°‹</button>
</div>

<div class="panel">
<div id="scoreBoard"></div>
</div>

<div id="cards"></div>

<script>

//////////////////////////////////////////////////////////////////
// Telegram
//////////////////////////////////////////////////////////////////

async function sendTG(msg){
    let token=document.getElementById("tgToken").value.trim()
    let chat=document.getElementById("tgChat").value.trim()
    if(!token||!chat) return

    fetch(`https://api.telegram.org/bot${token}/sendMessage`,{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({
            chat_id:chat,
            text:msg
        })
    })
}

function testPush(){
    sendTG("âœ… V12 å®Œæ•´å››å±¤ç­–ç•¥ æ¸¬è©¦æˆåŠŸ")
}

//////////////////////////////////////////////////////////////////
// æ¨æ’­æ§åˆ¶
//////////////////////////////////////////////////////////////////

function handlePush(symbol){

    let s=SYMBOL_POOL[symbol]
    if(!s) return

    // é¢¨æ§ï¼šæ­¢æè·é›¢å¤ªå°ä¸æ¨
    if(s.stopDistance<1.0) return

    if(s.state==="STRONG" && !s.pushLock){

        sendTG(
`ğŸ”¥ STRONG ${symbol}
ç¸½åˆ†:${s.score}

çµæ§‹:${s.scoreDetails.structure}
æ–œç‡:${s.scoreDetails.slope}
çªç ´:${s.scoreDetails.breakout}
çˆ†é‡:${s.scoreDetails.volume}
ATR:${s.scoreDetails.atr}
ATRè„«é‰¤:${s.scoreDetails.atrDecouple}
OI:${s.scoreDetails.oi}
OIè¶¨å‹¢:${s.scoreDetails.oiTrend}
åƒ¹æ ¼è„«é‰¤:${s.scoreDetails.priceDecouple}
çµæ§‹è„«é‰¤:${s.scoreDetails.structureDecouple}
é‡èƒ½è„«é‰¤:${s.scoreDetails.volumeDecouple}
POC:${s.scoreDetails.poc}

æ”¯æ’:${s.support.toFixed(4)}
æ­¢æè·é›¢:${s.stopDistance.toFixed(2)}%`
        )

        s.pushLock=true
    }

    if(s.whaleExit && !s.exitLock){

        sendTG(`âš  EXIT ${symbol} ä¸»åŠ›æ’¤é€€`)
        s.exitLock=true
    }
}

//////////////////////////////////////////////////////////////////
// è¨˜åˆ†æ¿
//////////////////////////////////////////////////////////////////

function updateScoreBoard(){

    let strong=0,breakN=0,build=0,radar=0

    Object.values(SYMBOL_POOL).forEach(s=>{
        if(s.state==="STRONG") strong++
        if(s.state==="BREAK") breakN++
        if(s.state==="BUILD") build++
        if(s.state==="RADAR") radar++
    })

    document.getElementById("scoreBoard").innerHTML=
        `STRONG:${strong} | BREAK:${breakN} | BUILD:${build} | RADAR:${radar}`
}

//////////////////////////////////////////////////////////////////
// å¡ç‰‡æ¸²æŸ“
//////////////////////////////////////////////////////////////////

function renderCards(){

    let container=document.getElementById("cards")
    container.innerHTML=""

    Object.keys(SYMBOL_POOL).forEach(symbol=>{

        let s=SYMBOL_POOL[symbol]
        if(!s.score) return

        let div=document.createElement("div")
        div.className="card "+s.state

        div.innerHTML=`
<b>${symbol}</b> ç‹€æ…‹:${s.state}<br>
ç¸½åˆ†:${s.score}<br>
<div class="small">
çµæ§‹:${s.scoreDetails.structure}
æ–œç‡:${s.scoreDetails.slope}
çªç ´:${s.scoreDetails.breakout}
çˆ†é‡:${s.scoreDetails.volume}
ATR:${s.scoreDetails.atr}
ATRè„«é‰¤:${s.scoreDetails.atrDecouple}
OI:${s.scoreDetails.oi}
OIè¶¨å‹¢:${s.scoreDetails.oiTrend}
åƒ¹æ ¼è„«é‰¤:${s.scoreDetails.priceDecouple}
çµæ§‹è„«é‰¤:${s.scoreDetails.structureDecouple}
é‡èƒ½è„«é‰¤:${s.scoreDetails.volumeDecouple}
POC:${s.scoreDetails.poc}
</div>
æ”¯æ’:${s.support?.toFixed(4)}<br>
æ­¢æè·é›¢:${s.stopDistance?.toFixed(2)}%<br>
${s.whaleExit?'<span class="alert">ä¸»åŠ›æ’¤é€€</span>':''}
`

        container.appendChild(div)

        handlePush(symbol)
    })

    document.getElementById("activeCount").innerText=
        `Active:${ACTIVE_SYMBOLS.size}`

    document.getElementById("engineStatus").innerText=
        ENGINE.running?"ON":"OFF"
}

//////////////////////////////////////////////////////////////////
// æœå°‹å–®å¹£
//////////////////////////////////////////////////////////////////

function manualSubscribe(){

    let s=document.getElementById("searchSymbol").value.toUpperCase()
    if(!s.endsWith("USDT")) s+="USDT"

    if(!SYMBOL_POOL[s]){
        SYMBOL_POOL[s]=createEmptySymbol()
    }

    enqueueSubscribe(s)
}

//////////////////////////////////////////////////////////////////
// UI æ›´æ–°å¾ªç’°
//////////////////////////////////////////////////////////////////

setInterval(()=>{
    if(!ENGINE.running) return
    updateScoreBoard()
    renderCards()
},2500)

</script>
