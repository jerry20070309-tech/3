<!-- =============================== -->
<!-- V9 Quant Engine - Part 1 -->
<!-- Market Engine + Data Engine -->
<!-- =============================== -->

<script>

////////////////////////////////////////////////////////////
// ÂÖ®ÂüüÊ†∏ÂøÉËÆäÊï∏
////////////////////////////////////////////////////////////

let MARKET_SOCKET = null
let SUB_SOCKET = null

let reconnectTimer = null

let ALL_SYMBOLS = []
let ACTIVE_SYMBOLS = new Set()

let SYMBOL_CACHE = {}
let OI_CACHE = {}
let BTC_CACHE = { k15: [], k1: [] }

let EXCLUDED_SYMBOLS = [
    "BTCUSDT",
    "ETHUSDT",
    "BNBUSDT",
    "SOLUSDT",
    "XRPUSDT",
    "ADAUSDT",
    "DOGEUSDT",
    "AVAXUSDT",
    "TRXUSDT",
    "DOTUSDT"
]

let METAL_KEYWORDS = ["GOLD","SILVER","XAU","XAG"]

////////////////////////////////////////////////////////////
// WebSocket - ÂÖ®Â∏ÇÂ†¥ Ticker Áõ£Êéß
////////////////////////////////////////////////////////////

function startMarketSocket(){

    if(MARKET_SOCKET){
        MARKET_SOCKET.close()
    }

    MARKET_SOCKET = new WebSocket("wss://fstream.binance.com/ws/!ticker@arr")

    MARKET_SOCKET.onmessage = function(event){

        let data = JSON.parse(event.data)

        data.forEach(ticker => {

            let symbol = ticker.s

            if(!symbol.endsWith("USDT")) return
            if(EXCLUDED_SYMBOLS.includes(symbol)) return
            if(METAL_KEYWORDS.some(k => symbol.includes(k))) return

            let quoteVolume = parseFloat(ticker.q)

            if(quoteVolume < 5000000) return   // ÊéíÈô§‰ΩéÊàê‰∫§Èáè

            if(!SYMBOL_CACHE[symbol]){
                SYMBOL_CACHE[symbol] = {
                    k15: [],
                    k1: [],
                    lastPrice: parseFloat(ticker.c),
                    volume: quoteVolume,
                    state: "IDLE"
                }
            }

            SYMBOL_CACHE[symbol].lastPrice = parseFloat(ticker.c)
            SYMBOL_CACHE[symbol].volume = quoteVolume

            ALL_SYMBOLS.push(symbol)

        })

        filterTopSymbols()

    }

    MARKET_SOCKET.onclose = function(){
        reconnectMarket()
    }

}

////////////////////////////////////////////////////////////
// Â∏ÇÂ†¥ÈÅéÊøæÔºàÊéíÈô§Ââç35Ôºâ
////////////////////////////////////////////////////////////

function filterTopSymbols(){

    let sorted = Object.keys(SYMBOL_CACHE)
        .sort((a,b)=>SYMBOL_CACHE[b].volume - SYMBOL_CACHE[a].volume)

    let sliced = sorted.slice(35,135)

    sliced.forEach(symbol=>{
        if(!ACTIVE_SYMBOLS.has(symbol)){
            subscribeSymbol(symbol)
        }
    })

}

////////////////////////////////////////////////////////////
// ÂãïÊÖãË®ÇÈñ± K Á∑ö + OI
////////////////////////////////////////////////////////////

function subscribeSymbol(symbol){

    if(ACTIVE_SYMBOLS.has(symbol)) return

    ACTIVE_SYMBOLS.add(symbol)

    if(!SUB_SOCKET || SUB_SOCKET.readyState !== 1){
        startSubSocket()
    }

    let streams = [
        `${symbol.toLowerCase()}@kline_15m`,
        `${symbol.toLowerCase()}@kline_1m`
    ]

    SUB_SOCKET.send(JSON.stringify({
        method:"SUBSCRIBE",
        params:streams,
        id:Date.now()
    }))

}

////////////////////////////////////////////////////////////
// Sub WebSocket
////////////////////////////////////////////////////////////

function startSubSocket(){

    SUB_SOCKET = new WebSocket("wss://fstream.binance.com/ws")

    SUB_SOCKET.onopen = function(){
        console.log("Sub socket connected")
    }

    SUB_SOCKET.onmessage = function(event){

        let msg = JSON.parse(event.data)

        if(!msg.stream) return

        let stream = msg.stream
        let data = msg.data

        let symbol = data.s

        if(stream.includes("kline_15m")){
            updateKline(symbol, data.k, "k15")
        }

        if(stream.includes("kline_1m")){
            updateKline(symbol, data.k, "k1")
        }

    }

    SUB_SOCKET.onclose = function(){
        reconnectSub()
    }

}

////////////////////////////////////////////////////////////
// Êõ¥Êñ∞ K Á∑öÁ∑©Â≠ò
////////////////////////////////////////////////////////////

function updateKline(symbol, k, type){

    if(!SYMBOL_CACHE[symbol]) return

    let close = parseFloat(k.c)
    let high = parseFloat(k.h)
    let low = parseFloat(k.l)
    let volume = parseFloat(k.v)

    let arr = SYMBOL_CACHE[symbol][type]

    arr.push({
        close,
        high,
        low,
        volume,
        time:k.t
    })

    if(type==="k15" && arr.length>120) arr.shift()
    if(type==="k1" && arr.length>100) arr.shift()

}

////////////////////////////////////////////////////////////
// OI ÊäìÂèñÔºàREST ÈôêÈÄüÂÆâÂÖ®ÁâàÔºâ
////////////////////////////////////////////////////////////

async function fetchOI(symbol){

    try{
        let res = await fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`)
        let data = await res.json()
        OI_CACHE[symbol] = parseFloat(data.openInterest)
    }catch(e){}
}

setInterval(()=>{
    ACTIVE_SYMBOLS.forEach(symbol=>{
        fetchOI(symbol)
    })
},5000)

////////////////////////////////////////////////////////////
// ÈáçÈÄ£Ê©üÂà∂
////////////////////////////////////////////////////////////

function reconnectMarket(){
    if(reconnectTimer) clearTimeout(reconnectTimer)
    reconnectTimer = setTimeout(()=>{
        startMarketSocket()
    },3000)
}

function reconnectSub(){
    if(reconnectTimer) clearTimeout(reconnectTimer)
    reconnectTimer = setTimeout(()=>{
        startSubSocket()
    },3000)
}

////////////////////////////////////////////////////////////
// ÂïüÂãï
////////////////////////////////////////////////////////////

startMarketSocket()

</script>
<!-- =============================== -->
<!-- V9 Quant Engine - Part 2 -->
<!-- Strategy Engine + Score System -->
<!-- =============================== -->

<script>

////////////////////////////////////////////////////////////
// Â∑•ÂÖ∑ÂáΩÊï∏
////////////////////////////////////////////////////////////

function MA(data, period){
    if(data.length < period) return 0
    let sum = 0
    for(let i=data.length-period;i<data.length;i++){
        sum += data[i].close
    }
    return sum/period
}

function ATR(data, period){
    if(data.length < period+1) return 0
    let trs = []
    for(let i=1;i<data.length;i++){
        let high = data[i].high
        let low = data[i].low
        let prevClose = data[i-1].close
        let tr = Math.max(high-low, Math.abs(high-prevClose), Math.abs(low-prevClose))
        trs.push(tr)
    }
    let slice = trs.slice(-period)
    return slice.reduce((a,b)=>a+b,0)/period
}

function getHigh(data, n){
    if(data.length<n) return 0
    let slice = data.slice(-n)
    return Math.max(...slice.map(c=>c.high))
}

function getLow(data, n){
    if(data.length<n) return 0
    let slice = data.slice(-n)
    return Math.min(...slice.map(c=>c.low))
}

////////////////////////////////////////////////////////////
// BTC ËÑ´Èâ§Á∑©Â≠ò
////////////////////////////////////////////////////////////

function updateBTC(){

    let btc = SYMBOL_CACHE["BTCUSDT"]
    if(!btc) return

    BTC_CACHE.k15 = btc.k15
    BTC_CACHE.k1 = btc.k1

}

setInterval(updateBTC,2000)

////////////////////////////////////////////////////////////
// ‰∏ªÁ≠ñÁï•ÂºïÊìé
////////////////////////////////////////////////////////////

function runStrategy(symbol){

    let cache = SYMBOL_CACHE[symbol]
    if(!cache) return

    let k15 = cache.k15
    let k1 = cache.k1

    if(k15.length < 100 || k1.length < 50) return

    let price = cache.lastPrice

    ////////////////////////////////////////////
    // ÂùáÁ∑ö
    ////////////////////////////////////////////

    let ma7 = MA(k15,7)
    let ma20 = MA(k15,20)
    let ma25 = MA(k15,25)
    let ma99 = MA(k15,99)

    ////////////////////////////////////////////
    // È´òÈªûÁ™ÅÁ†¥
    ////////////////////////////////////////////

    let high35 = getHigh(k15,35)
    let breakout = price > high35

    ////////////////////////////////////////////
    // ÁàÜÈáè
    ////////////////////////////////////////////

    let recent = k15.slice(-35)
    let avgVol = recent.reduce((a,b)=>a+b.volume,0)/35
    let volNow = k15[k15.length-1].volume
    let volumeRatio = volNow / avgVol

    ////////////////////////////////////////////
    // POC Ê®°Êì¨ÔºàÁî®Ëøë‰ººÂØÜÈõÜÂçÄÔºâ
    ////////////////////////////////////////////

    let priceBuckets = {}
    recent.forEach(c=>{
        let key = Math.round(c.close*100)/100
        if(!priceBuckets[key]) priceBuckets[key]=0
        priceBuckets[key]+=c.volume
    })

    let pocPrice = Object.keys(priceBuckets)
        .sort((a,b)=>priceBuckets[b]-priceBuckets[a])[0]

    let pocBreak = price > parseFloat(pocPrice)

    ////////////////////////////////////////////
    // OI Âà§Êñ∑
    ////////////////////////////////////////////

    let oi = OI_CACHE[symbol] || 0
    let oiPrev = cache.prevOI || oi
    let oiChange = (oi - oiPrev) / oiPrev * 100
    cache.prevOI = oi

    ////////////////////////////////////////////
    // BTC ËÑ´Èâ§ÂõõÂ±§
    ////////////////////////////////////////////

    let btc15 = BTC_CACHE.k15
    let btcScore = 0

    if(btc15.length>35){

        let btcHigh35 = getHigh(btc15,35)
        let btcPrice = btc15[btc15.length-1].close

        let structureDiff = breakout && btcPrice < btcHigh35
        if(structureDiff) btcScore += 10

        let btcVol = btc15[btc15.length-1].volume
        if(volumeRatio > 1.6 && btcVol < avgVol) btcScore += 10

        let btcATR = ATR(btc15,14)
        let altATR = ATR(k15,14)

        if(altATR > btcATR) btcScore += 10

    }

    ////////////////////////////////////////////
    // 1m ÊîØÊíêÊ≠¢Êêç
    ////////////////////////////////////////////

    let support = getLow(k1,50)
    let stopDistance = (price-support)/price*100

    ////////////////////////////////////////////
    // Ë©ïÂàÜÁ≥ªÁµ±
    ////////////////////////////////////////////

    let scoreDetails = {
        breakout: breakout?20:0,
        structure: (ma7>ma20 && ma20>ma25 && ma25>ma99)?20:0,
        volume: volumeRatio>2?20:(volumeRatio>1.6?15:0),
        poc: pocBreak?15:0,
        oi: oiChange>3?15:(oiChange>1?10:0),
        btc: btcScore
    }

    let totalScore = Object.values(scoreDetails)
        .reduce((a,b)=>a+b,0)

    ////////////////////////////////////////////
    // ÁãÄÊÖãÊ©ü
    ////////////////////////////////////////////

    let state = "IDLE"

    if(totalScore>=95) state="STRONG"
    else if(totalScore>=85) state="BREAK"
    else if(totalScore>=75) state="WATCH"
    else if(totalScore>=60) state="RADAR"

    cache.state = state
    cache.score = totalScore
    cache.scoreDetails = scoreDetails
    cache.support = support
    cache.stopDistance = stopDistance

}

////////////////////////////////////////////////////////////
// È¢®ÊéßÂª∫Ë≠∞ÔºàÈ´òÊßìÊ°øÊ®°ÂûãÔºâ
////////////////////////////////////////////////////////////

function getRiskSuggestion(symbol){

    let cache = SYMBOL_CACHE[symbol]
    if(!cache) return null

    let stop = cache.stopDistance

    if(stop<=0) return null

    let leverage = Math.min(25, Math.floor(10/stop))

    return {
        stopPercent: stop.toFixed(2),
        leverage
    }

}

////////////////////////////////////////////////////////////
// ÈÄ±ÊúüÊÄßË∑ëÁ≠ñÁï•
////////////////////////////////////////////////////////////

setInterval(()=>{
    ACTIVE_SYMBOLS.forEach(symbol=>{
        runStrategy(symbol)
    })
},2000)

</script>
<!-- =============================== -->
<!-- V9 Quant Engine - Part 3 -->
<!-- UI + Push + Exit Logic -->
<!-- =============================== -->

<style>
body{background:#050505;color:#d4d4d8;font-family:monospace}
.card{background:#0f0f11;border:1px solid #222;padding:10px;border-radius:6px;margin-bottom:10px}
.STRONG{border:2px solid #22c55e}
.BREAK{border:2px solid #3b82f6}
.WATCH{border:2px solid #f59e0b}
.RADAR{border:2px solid #a855f7}
.IDLE{border:1px solid #222}
.exit{border:2px solid #ef4444}
</style>

<div style="padding:10px">

<div style="margin-bottom:10px">
<input id="tgToken" placeholder="TG BOT TOKEN">
<input id="tgChat" placeholder="CHAT ID">
<input id="searchSymbol" placeholder="ÊêúÂ∞ãÂπ£ (‰æãÂ¶Ç ARBUSDT)">
<button onclick="searchSymbol()">ÊêúÂ∞ã</button>
</div>

<div id="symbolContainer"></div>

</div>

<script>

////////////////////////////////////////////////////////////
// Telegram Êé®Êí≠
////////////////////////////////////////////////////////////

async function sendTG(msg){
    let token=document.getElementById("tgToken").value
    let chat=document.getElementById("tgChat").value
    if(!token||!chat) return

    await fetch(`https://api.telegram.org/bot${token}/sendMessage`,{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({chat_id:chat,text:msg})
    })
}

////////////////////////////////////////////////////////////
// Âá∫Â†¥ÈÇèËºØ
////////////////////////////////////////////////////////////

function checkExit(symbol){

    let cache = SYMBOL_CACHE[symbol]
    if(!cache) return

    let price = cache.lastPrice
    let support = cache.support

    if(price < support){
        cache.state="EXIT"
        sendTG(`‚ö† Âá∫Â†¥ ${symbol}\nË∑åÁ†¥ÊîØÊíê\nÂÉπÊ†º:${price}`)
    }

    let k15 = cache.k15
    if(k15.length<10) return

    let lastVol = k15[k15.length-1].volume
    let prevVol = k15[k15.length-2].volume

    if(lastVol < prevVol*0.6){
        sendTG(`‚ö† ÂãïËÉΩÊ∂àÂ§± ${symbol}`)
    }

    let oi = OI_CACHE[symbol]
    if(oi && cache.prevOI && oi < cache.prevOI){
        sendTG(`‚ö† ‰∏ªÂäõÊí§ÈÄÄ ${symbol}`)
    }

}

////////////////////////////////////////////////////////////
// UI Êõ¥Êñ∞
////////////////////////////////////////////////////////////

function renderUI(){

    let container=document.getElementById("symbolContainer")
    container.innerHTML=""

    Object.keys(SYMBOL_CACHE).forEach(symbol=>{

        let cache=SYMBOL_CACHE[symbol]
        if(!cache.score) return

        let risk=getRiskSuggestion(symbol)

        let div=document.createElement("div")
        div.className="card "+cache.state

        div.innerHTML=`
        <div><b>${symbol}</b> ÁãÄÊÖã: ${cache.state}</div>
        <div>Á∏ΩÂàÜ: ${cache.score}</div>
        <div>Á™ÅÁ†¥: ${cache.scoreDetails.breakout}</div>
        <div>ÁµêÊßã: ${cache.scoreDetails.structure}</div>
        <div>ÁàÜÈáè: ${cache.scoreDetails.volume}</div>
        <div>POC: ${cache.scoreDetails.poc}</div>
        <div>OI: ${cache.scoreDetails.oi}</div>
        <div>ËÑ´Èâ§: ${cache.scoreDetails.btc}</div>
        <div>ÊîØÊíê: ${cache.support?.toFixed(4)}</div>
        <div>Ê≠¢ÊêçË∑ùÈõ¢: ${cache.stopDistance?.toFixed(2)}%</div>
        <div>Âª∫Ë≠∞ÊßìÊ°ø: ${risk?risk.leverage:"-"}</div>
        <div>OIÂÄº: ${OI_CACHE[symbol]||"-"}</div>
        <div>ÂÉπÊ†º: ${cache.lastPrice}</div>
        `

        container.appendChild(div)

        if(cache.state==="STRONG"){
            sendTG(`üî• Âº∑‰ø°Ëôü ${symbol}\nÂàÜÊï∏:${cache.score}\nÂÉπÊ†º:${cache.lastPrice}`)
        }

        checkExit(symbol)

    })

}

setInterval(renderUI,3000)

////////////////////////////////////////////////////////////
// ÊêúÂ∞ãÂäüËÉΩ
////////////////////////////////////////////////////////////

function searchSymbol(){

    let s=document.getElementById("searchSymbol").value.toUpperCase()
    if(!s.endsWith("USDT")) s+="USDT"

    if(!SYMBOL_CACHE[s]){
        SYMBOL_CACHE[s]={
            k15:[],
            k1:[],
            state:"IDLE"
        }
    }

    subscribeSymbol(s)

}

</script>
